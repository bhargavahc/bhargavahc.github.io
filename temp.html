<!DOCTYPE html>
<html>
    <head>
        <title>Programs</title>
    </head>
    <body>
<h1>1st program</h1>
<pre>
    LEX PART
%{
#include "y.tab.h"
#include &ltstdlib.h>
extern int yylval;
%}
%%
[0-9]+ {yylval=atoi(yytext);
return NUM;}
\n {return 0;}
. {return yytext[0];}
%%
YACC PART
%{
#include&ltstdio.h>
int valid=1;
%}
%token NUM
%left '+' '-'
%left '*' '/'
%%
Stmt:expr{if(valid)
{
printf("Result=%d\n",$$);}
}
expr:expr'+'expr {$$=$1+$3;}
 |expr'-'expr {$$=$1-$3;}
 |expr'*'expr {$$=$1*$3;}
 |expr'/'expr {if($3==0){
valid=0;printf("Divide by zero error\n");}
else
$$=$1/$3;}
 |'('expr')' {$$=$2;}
 |NUM {$$=$1;}
 ;
%%
main()
{
printf("Enter arithmetic exression:\n");
yyparse();
if(valid==1)
printf("Expression is valid\n");
}
int yyerror()
{
printf("Invalid expression\n");
exit(0);
}
</pre>

<pre>
    <h1>2nd program</h1>
    LEX PART
%{
#include "y.tab.h"
%}
%%
a {return A;}
b {return B;}
\n {return 0;}
. {return yytext[0];}
%%
YACC PART
%{
#include &ltstdio.h>
int aCount=0,n;
%}
%token A
%token B
%%
s : X B { if (aCount&ltn || aCount>n) 
 {
YYFAIL();
}}
X : X T | T
T : A { aCount++;} 
 ;
%%
int main()
{ printf("Enter the value of n \n");
scanf("%d",&n);
printf("Enter the string\n");
yyparse();
printf("Valid string\n");
}
int YYFAIL()
{
printf("Invalid count of 'a'\n");
exit(0);
}
int yyerror()
{
    printf("Invalid string\n");
exit(0);
}
</pre>

<pre>
    <h1>5h Program</h1>
    #include&ltstdio.h>
        #include&ltstdlib.h>
        #include&ltctype.h>
        char op[2],arg1[5],arg2[5],result[5];
        void main()
        {
        FILE *fp1,*fp2;
        fp1=fopen("5input.txt","r");
        fp2=fopen("5output.txt","w");
        while(!feof(fp1))
        {
        fscanf(fp1,"%s%s%s%s",result,arg1,op,arg2);
        if(strcmp(op,"+")==0)
        {
        fprintf(fp2,"\nMOV R0,%s",arg1);
        fprintf(fp2,"\nADD R0,%s",arg2);
        fprintf(fp2,"\nMOV %s,R0",result);
        }if(strcmp(op,"*")==0)
        {
        fprintf(fp2,"\nMOV R0,%s",arg1);
        fprintf(fp2,"\nMUL R0,%s",arg2);
        fprintf(fp2,"\nMOV %s,R0",result);
        }
        if(strcmp(op,"-")==0)
        {
        fprintf(fp2,"\nMOV R0,%s",arg1);
        fprintf(fp2,"\nSUB R0,%s",arg2);
        fprintf(fp2,"\nMOV %s,R0",result);
        }
        if(strcmp(op,"/")==0)
        {
        fprintf(fp2,"\nMOV R0,%s",arg1);
        fprintf(fp2,"\nDIV R0,%s",arg2);
        fprintf(fp2,"\nMOV %s,R0",result);
        }
        if(strcmp(op,"=")==0)
        {
        fprintf(fp2,"\nMOV R0,%s",arg1);
        fprintf(fp2,"\nMOV %s,R0\n",result);
        } }
        fclose(fp1);
fclose(fp2);
}
</pre>
<pre>
    <h1>6b</h1>
    LEX PART
%{
#include &ltstdio.h>
#include "y.tab.h"
%}
%%
int|char|bool|float|void|for|do|while|if|else|return|void|main {printf("keyword is 
%s\n",yytext);return KEY;}
[+|-|*|/|=|<|>] {printf("operator is %s\n",yytext);return OP;}
[a-zA-Z][_a-zA-Z0-9]* {printf("identifier is %s\n",yytext);return ID;}
. ;
%%
YACC PART
%{
#include &ltstdio.h>
#include &ltstdlib.h>
int id=0, key=0, op=0;
%}
%token ID KEY OP 
%%
input: ID input { id++; }
| KEY input { key++; }
| OP input {op++;}
| ID { id++; }
| KEY { key++; }
| OP { op++;}
;
%%
extern FILE *yyin;
void main(int argc ,char** argv) 
{
yyin = fopen(argv[1],"r");
yyparse();
printf("Keywords = %d\nIdentifiers = %d\noperators = %d\n", key,id, op);
}
void yyerror()
{
printf("Not valid");
}
</pre>



        <strong>Cube Spin (3rd Program) </strong>
        <pre>
#include&ltstdlib.h>
#include&ltGL/glut.h>
GLfloat vertices[][3] = {{-1.0,-1.0,-1.0},{1.0,-1.0,-1.0}, {1.0,1.0,-1.0}, {-1.0,1.0,-1.0}, 
                {-1.0,-1.0,1.0}, {1.0,-1.0,1.0}, {1.0,1.0,1.0}, {-1.0,1.0,1.0}};
GLfloat normals[][3] = {{-1.0,-1.0,-1.0},{1.0,-1.0,-1.0}, {1.0,1.0,-1.0}, {-1.0,1.0,-1.0}, 
                {-1.0,-1.0,1.0}, {1.0,-1.0,1.0}, {1.0,1.0,1.0}, {-1.0,1.0,1.0}};
GLfloat colors[][3] = {{0.0,0.0,0.0},{1.0,0.0,0.0}, {1.0,1.0,0.0}, {0.0,1.0,0.0},{0.0,0.0,1.0}, {1.0,0.0,1.0}, {1.0,1.0,1.0}, {0.0,1.0,1.0}};

void  polygon(int a, int b, int c , int d)
{
/* draw a polygon via list of vertices */
glBegin(GL_POLYGON);
glColor3fv(colors[a]);
glNormal3fv(normals[a]);
glVertex3fv(vertices[a]);
glColor3fv(colors[b]);
glNormal3fv(normals[b]);
glVertex3fv(vertices[b]);
glColor3fv(colors[c]);
glNormal3fv(normals[c]);
glVertex3fv(vertices[c]);
glColor3fv(colors[d]);
glNormal3fv(normals[d]);
glVertex3fv(vertices[d]);
glEnd();
}
void  colorcube(void)
{
/* map vertices to faces */
polygon(0,3,2,1);
polygon(2,3,7,6);
polygon(0,4,7,3);
polygon(1,2,6,5);
polygon(4,5,6,7);
polygon(0,1,5,4);
}
static GLfloat theta[] = {0.0,0.0,0.0};
static GLint axis = 2;

void  display(void)
{
/* display callback, clear frame buffer and z buffer,
rotate cube and draw, swap buffers */
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
glLoadIdentity();
glRotatef(theta[0], 1.0, 0.0, 0.0);
glRotatef(theta[1], 0.0, 1.0, 0.0);
glRotatef(theta[2], 0.0, 0.0, 1.0);
colorcube();
glFlush();
glutSwapBuffers();
}

void  spinCube()
{
/* Idle callback, spin cube 2 degrees about selected axis */
theta[axis] += 1.0;
if( theta[axis] > 360.0 ) theta[axis] -= 360.0;
/* display(); */
glutPostRedisplay();
}

void  mouse(int btn, int state, int x, int y)
{
/* mouse callback, selects an axis about which to rotate */
if(btn==GLUT_LEFT_BUTTON && state == GLUT_DOWN) axis = 0;
if(btn==GLUT_MIDDLE_BUTTON && state == GLUT_DOWN) axis = 1;
if(btn==GLUT_RIGHT_BUTTON && state == GLUT_DOWN) axis = 2;
}
void  myReshape(int w, int h)
{
glViewport(0, 0, w, h);
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
if (w <= h)
glOrtho(-2.0, 2.0, -2.0 * (GLfloat) h / (GLfloat) w, 2.0 * (GLfloat) h / (GLfloat) w, -10.0, 10.0);
else
glOrtho(-2.0 * (GLfloat) w / (GLfloat) h, 2.0 * (GLfloat) w / (GLfloat) h, -2.0, 2.0, -10.0, 10.0);
glMatrixMode(GL_MODELVIEW);
}

void  main(int argc, char **argv)
{
 glutInit(&argc, argv);
/* need both double buffering and z buffer */
glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
glutInitWindowSize(500, 500);
glutCreateWindow("Rotating a Color Cube");
glutReshapeFunc(myReshape);
glutDisplayFunc(display);
glutIdleFunc(spinCube);
glutMouseFunc(mouse);
glEnable(GL_DEPTH_TEST); /* Enable hidden--surface--removal */
glutMainLoop();
}

        </pre>
<br>
<br>
<strong>Perspective viewing (4th Program)</strong>
<pre>
#include&ltstdlib.h>
#include&ltGL/glut.h>
GLfloat vertices[][3] = {{-1.0,-1.0,-1.0},{1.0,-1.0,-1.0}, {1.0,1.0,-1.0}, {-1.0,1.0,-1.0}, 
                {-1.0,-1.0,1.0}, {1.0,-1.0,1.0}, {1.0,1.0,1.0}, {-1.0,1.0,1.0}};
GLfloat normals[][3] = {{-1.0,-1.0,-1.0},{1.0,-1.0,-1.0}, {1.0,1.0,-1.0}, {-1.0,1.0,-1.0}, 
                {-1.0,-1.0,1.0}, {1.0,-1.0,1.0}, {1.0,1.0,1.0}, {-1.0,1.0,1.0}};
GLfloat colors[][3] = {{0.0,0.0,0.0},{1.0,0.0,0.0}, {1.0,1.0,0.0}, {0.0,1.0,0.0}, {0.0,0.0,1.0},
            {1.0,0.0,1.0}, {1.0,1.0,1.0}, {0.0,1.0,1.0}};

void  polygon(int a, int b, int c , int d)
{
glBegin(GL_POLYGON);
glColor3fv(colors[a]);
glNormal3fv(normals[a]);
glVertex3fv(vertices[a]);
glColor3fv(colors[b]);
glNormal3fv(normals[b]);
glVertex3fv(vertices[b]);
glColor3fv(colors[c]);
glNormal3fv(normals[c]);
glVertex3fv(vertices[c]);
glColor3fv(colors[d]);
glNormal3fv(normals[d]);
glVertex3fv(vertices[d]);
glEnd();
}
void colorcube()
{
polygon(0,3,2,1);
polygon(2,3,7,6);
polygon(0,4,7,3);
polygon(1,2,6,5);
polygon(4,5,6,7);
polygon(0,1,5,4);
}

static GLfloat theta[] = {0.0,0.0,0.0};
static GLint axis = 2;
static GLdouble viewer[]= {0.0, 0.0, 5.0}; /* initial viewer location */

void display(void)
{
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
/* Update viewer position in modelview matrix */
glLoadIdentity();
gluLookAt(viewer[0],viewer[1],viewer[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
/* rotate cube */
glRotatef(theta[0], 1.0, 0.0, 0.0);
glRotatef(theta[1], 0.0, 1.0, 0.0);
glRotatef(theta[2], 0.0, 0.0, 1.0);
colorcube();
glFlush();
glutSwapBuffers();
}

void mouse(int btn, int state, int x, int y)
{
if(btn==GLUT_LEFT_BUTTON && state == GLUT_DOWN) axis = 0;
if(btn==GLUT_MIDDLE_BUTTON && state == GLUT_DOWN) axis = 1;
if(btn==GLUT_RIGHT_BUTTON && state == GLUT_DOWN) axis = 2;
theta[axis] += 2.0;
if( theta[axis] > 360.0 ) theta[axis] -= 360.0;
display();
}

void keys(unsigned char key, int x, int y)
{
/* Use x, X, y, Y, z, and Z keys to move viewer */
if(key == 'x') viewer[0]-= 1.0;
if(key == 'X') viewer[0]+= 1.0;
if(key == 'y') viewer[1]-= 1.0;
if(key == 'Y') viewer[1]+= 1.0;
if(key == 'z') viewer[2]-= 1.0;
if(key == 'Z') viewer[2]+= 1.0;
display();
}

void myReshape(int w, int h)
{
glViewport(0, 0, w, h);
/* Use a perspective view */
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
if(w<=h)
glFrustum(-2.0, 2.0, -2.0*(GLfloat) h/(GLfloat) w,2.0* (GLfloat) h / (GLfloat) w,2.0, 20.0);
else 
glFrustum(-2.0, 2.0, -2.0*(GLfloat) w/(GLfloat) h,2.0* (GLfloat) w/(GLfloat) h, 2.0, 20.0);
/* Or we can use gluPerspective */
/* gluPerspective(45.0, w/h, -10.0, 10.0); */
glMatrixMode(GL_MODELVIEW);
}

void main(int argc, char **argv)
{
glutInit(&argc, argv);
glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
glutInitWindowSize(500, 500);
glutCreateWindow("Colorcube Viewer");
glutReshapeFunc(myReshape);
glutDisplayFunc(display);
glutMouseFunc(mouse);
glutKeyboardFunc(keys);
glEnable(GL_DEPTH_TEST);
glutMainLoop();
}        
</pre>
<br>
<br>
        
             <strong> 7th Program</strong>
                <pre>
                        #include&ltstdio.h> 
                        #include&ltstdlib.h>
                        
                        int no;
                        void roundrobin(int,int,int[],int[]);
                        void srtf();
                        main()
                        {
                            int n,tq,choice;
                            int bt[10], st[10], i,j,k;
                            for(;;)
                            {
                                printf("Enter choice\n");
                                printf("1.Round Robin \n2.str \n3.Exit\n");
                                scanf("%d",&choice);
                                switch(choice)
                                {
                                    case 1: printf("Round robin scheduling algorithm\n");
                                        printf("Enter the number of process\n");
                                        scanf("%d",&n);
                                        printf("Enter burst time for sequences\n");
                                        for(i=0;i < n ; i++)

                                        {
                                             scanf("%d" ,&bt[i]);
                                            st[i]=bt[i];
                                        }
                                        
                                        printf("Enter time quantum\n");
                                        scanf("%d",&tq);
                                        roundrobin(n,tq,st,bt);
                                        break;
                                    case 2: printf("\n\n-------------------Shortest remaining time------\n\n");
                                            printf("\n");
                                        srtf();
                                        break;
                                    case 3: exit(0);
                                        break;
                                }
                            }
                        }
                            
                        void roundrobin(int n, int tq, int st[], int bt[])
                        {
                            int time=0;
                            int tat[10],wt[10],i,count=0,swt=0,stat=0,temp1,sq=0,j,k;
                            float awt=0.0, atat=0.0; 
                            while(1)
                            {
                        for(i=0,count=0;i< n;i++)
                                {
                                    temp1=tq;
                                    if(st[i]==0)
                                    {
                                        count++;
                                        continue;
                                    }
                                    if (st[i]>tq)
                                        st[i]=st[i]-tq;
                                    else if(st[i]>=0)
                                    {
                                        temp1=st[i];
                                        st[i]=0;
                                    }
                                    sq=sq+temp1;
                                    tat[i]=sq;
                                }
                                if(n==count)
                                break;
                            }
                            for(i=0;i< n;i++)
                            {
                                wt[i]=tat[i]-bt[i];
                                swt=swt+wt[i];
                                stat=stat+tat[i];
                            }
                            awt=(float)swt/n;
                            atat=(float)stat/n;
                            printf("process no   burst time  waiting time 	turnaround time\n");
                            for(i=0;i< n;i++)
                                printf("%d \t\t %d \t\t %d \t\t %d \t\t\n",i+1,bt[i],wt[i],tat[i]);
                            printf("average waiting time is%f\n avg turnaround time is %f\n",awt,atat);
                            
                        }
                        
                        void srtf()
                        {
                            int n,j=0,st[10],bt[10],rt[10],remain=0,smallest,time=0,i,endtime,swt=0,stat=0;
                            printf("enter the no. of process:");
                            scanf("%d",&n);
                            for(i=0;i< n;i++)
                            {
                                printf("enter the arrivaltime for p[%d]:",i+1);
                                scanf("%d",&st[i]);
                                printf("enter the burst time for p[%d]:",i+1);
                                scanf("%d",&bt[i]);
                                rt[i]=bt[i];
                            }
                            rt[100]=999;
                        printf("process\t|writing time\t|turnarround time\n");
                            for(time=0;remain!=n;time++)
                             {
                                 smallest=100;
                                 for(i=0;i< n;i++)
                                {
                                    if(st[i]<=time && rt[i]< rt[smallest] && rt[i]>0)
                                    {
                                        smallest=i;
                                    }
                                }
                                rt[smallest]--;
                                if(rt[smallest]==0)
                                {
                                    remain++;
                                    endtime=time+1;
                                    j=smallest;
                                    printf("p[%d]\t|\t%d\t|\t%d\n",smallest+1,endtime-bt[j]-st[j],endtime-st[j]);
                                    swt +=endtime-bt[j]-st[j];
                                    stat +=endtime-st[j];
                                }
                            }
                            float awt=0.0,atat=0.0;
                            awt=(float)swt/n;
                            atat=(float)stat/n;
                            printf("average waiting time:%f\n",awt);
                            printf("average turnarround time:%f\n",atat);
                        }
                        
                        
                </pre>
           

            
            </body>
</html>